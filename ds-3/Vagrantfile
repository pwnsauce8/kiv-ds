#
# *** KIV/DS - Task 3
# Distributed cache
#


# Settings
# ---------------------------------------
TREE_LEVEL = 3
CLIENTS_COUNT = (2**TREE_LEVEL) - 1
PORT = 5000


# Configure
VAGRANTFILE_API_VERSION = "2"
# set docker as the default provider
ENV['VAGRANT_DEFAULT_PROVIDER'] = 'docker'
# disable parallellism so that the containers come up in order
ENV['VAGRANT_NO_PARALLEL'] = "1"
ENV['FORWARD_DOCKER_PORTS'] = "1"
# minor hack enabling to run the image and configuration trigger just once
ENV['VAGRANT_EXPERIMENTAL']="typed_triggers"

unless Vagrant.has_plugin?("vagrant-docker-compose")
  system("vagrant plugin install vagrant-docker-compose")
  puts "Dependencies installed, please try the command again."
  exit
end

# Names of Docker images built:
ZOONODE_IMAGE  = "ds/task-3/zoonode:0.1"
CLIENT_IMAGE   = "ds/task-3/client:0.1"
ZOONAVIGATOR_IMAGE = "elkozmon/zoonavigator:latest"
# Subnet to use:
SUBNET = "10.0.1."

# Node definitions
CLIENT  = { :nameprefix => "client-",
            :subnet => SUBNET,
            :ip_offset => 10,
            :image => CLIENT_IMAGE,
            :config => "client/client.cfg"
          }

# Root information
ROOT_ID = 0
ROOT_IP = "#{CLIENT[:subnet]}#{CLIENT[:ip_offset] + ROOT_ID}"

ZOO_SERVERS="#{SUBNET}100"

# Common configuration
Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

  # Before the 'vagrant up' command is started, build docker images:
  config.trigger.before :up, type: :command do |trigger|
    trigger.name = "Build docker images"
    trigger.ruby do |env, machine|
        # --- start of Ruby script ---
        # Build Zoonode image:
        puts "Building Zoonode image:"
        `docker build zoonode -t "#{ZOONODE_IMAGE}"`
        # Build client node image:
        puts "Building client node image:"
        `docker build client -t "#{CLIENT_IMAGE}"`
        # --- end of Ruby script ---
    end
  end

  config.vm.synced_folder ".", "/vagrant", disabled: true
  config.ssh.insert_key = false

  # Definition of Zoonode
  config.vm.define "zoonode" do |s|
    s.vm.network "private_network", ip: "#{SUBNET}100"
    s.vm.hostname = "zoonode" 
    s.vm.provider "docker" do |d|
      d.image = ZOONODE_IMAGE
      d.name = "zoonode"
      d.has_ssh = true
    end
    s.vm.post_up_message = "Node 'zoonode' up and running. You can access the node with 'vagrant ssh zoonode'}"
  end


  # Definition of N - 1 client nodes
  (0..CLIENTS_COUNT).each do |i|
    node_ip_addr = "#{CLIENT[:subnet]}#{CLIENT[:ip_offset] + i}"
    node_name = "#{CLIENT[:nameprefix]}#{i}"
    # Definition of client node
    config.vm.define node_name do |s|
      s.vm.network "private_network", ip: node_ip_addr
      s.vm.network "forwarded_port", guest: 80, host: PORT, host_ip: "0.0.0.0", auto_correct: true
      s.vm.hostname = node_name
      s.vm.provider "docker" do |d|
        d.image = CLIENT[:image]
        d.name = node_name
        d.has_ssh = true
        d.env = { 
          "ZOO_SERVERS" => "#{ZOO_SERVERS}",
          "NODE_IP" => node_ip_addr, 
          "ROOT_IP" => "#{ROOT_IP}"
        }
      end
      s.vm.post_up_message = "Node #{node_name} up and running. You can access the node with 'vagrant ssh #{node_name}'}"
    end
  end

  # Definition of Zoonavigator
  config.vm.define "zoonavigator" do |s|
    s.vm.network "private_network", ip: "#{SUBNET}101"
    s.vm.network "forwarded_port", guest: 9000, host: 9000, host_ip: "0.0.0.0"
    s.vm.hostname = "zoonavigator"
    s.vm.provider "docker" do |d|
      d.image = ZOONAVIGATOR_IMAGE
      d.name = "zoonavigator"
      d.has_ssh = false
      d.env = { "HTTP_PORT" => "9000" }
    end
    s.vm.post_up_message = "Node 'zoonavigator' up and running. You can access the node with 'vagrant ssh zoonode'}"
  end


end

# EOF

